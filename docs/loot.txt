mincountOrRef mediumint(9)

字段定义 
¦当正数时: 物品最少数量 
¦当负数时: 引用另一个模板. 
0值被忽略
正值含义十分清晰. 引用可以指向整个模板，也可以指向模板中的特定组。
当 mincountOrRef < 0, group = 0 时引用 ( entry 等于 "-mincountOrRef") 且包含被引用模板中所有items到当前。 

简单说. maxcount 字段值作为 引用的重复因子 - 引用将被处理不只一次，而是引用maxcount次. 
因此，如果被引用的模板可以处理 3 到 10 个item (看运气) 而 maxcount 是 '5' 那么引用的 15 到 50 个items将被添加到 loot中. 可怕的例子, 不是吗? 

实际上模板重复引用没有很好的例子, 但有的时候对组引用是很有用的。 

注意. 自引用 (模板引用会引用到自己) 产生循环引用 (模板 A引用模板 B, 模板 B 包含模板 A) 来自完全不同的引用方向。

如果你人为制造这样的引用
INSERT INTO `creature_loot_template` (`entry`,`item`,`mincountOrRef`) VALUES ('21215','0','-21215');

内核在处理 21215 时会崩溃. 这就是为什么自引用和循环引用是禁止的. 组引用 mincountOrRef < 0, group > 0 组引用包含另一个模板 (被引用模板记录 entry 等于 "-mincountOrRef") 仅引用group - id 等于 `groupid` 字段的引用. 因此这个引用会添加0或 1 个item 到 loot (如果 maxcount 等于 1). 意味着 maxcount 字段值和模板引用中描述一样。

注意没有办法引用一个组的一部分，组引用有相同的引用格式。

两种类型的组引用: ¦外部引用当组引用行entry不同于引用组 ¦

内部引用: 当组引用行使用entry作为引用组ID。 

组引用基本使用是避免复制组定义，当有几个loot 源有相同的loot部分。这种情况下:

 ¦要一次次定义相同的组内容 (items/drop chances) . 最简单, 但是消费内存最大。

 ¦要定义一次组成为一次loot源的一部分，包含组引用在loot定义中，在其它源中定义而 不是 重复定义组。

 ¦要人工定义1次组loot  (有 entry 没有对应的任何源) 且包含组引用在每个相关loot源的loot 定义中。 

第一个方法已经废弃, 第二个第三使用外部引用. UDB 推荐使用第三种方法.因为引用有机会处理，这样就可能用于 zone 或 world 的drop 定义。 
这些暴落通常有不同的机会和不同的源 (低/高技能对象, 非精英/精英等等) 但具有相同的loot内容。

推荐这样定义: 人工设置组有100% 机会 (如果可能使用相同几率的entries ) 
¦要包含引用到每个相关的loot源为这个组设置drop机会. 有些boss掉落不止1个物品 (两个或者三个)。 掉落统计看起来象同一个组是rolled 2 或者 3 次，且每次一个 item (可能一样) 被选择. 这简单为每个item定义一个组, 但如何为第二和第三定义? 

我们可以: 
¦重复组定义 2 (或者 3) 次，设定组暴率
¦定义组一次包含 1 (或 2) 内部引用. ¦定义组1次作为loot定义的一部分，且包含 2 (或 3) 外部组定义。
¦定义组1次，作为loot定义的一部分且包含外部组引用，复制因子为2 (或3)。 
效果一样. 但是 - 第一种方法非常低效而被废弃. 我们推荐使用直接的方式。